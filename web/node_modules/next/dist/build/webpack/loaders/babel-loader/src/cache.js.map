{"version":3,"sources":["../../../../../../build/webpack/loaders/babel-loader/src/cache.js"],"names":["read","cacheDirectory","etag","cachedResult","traceAsyncFn","cacache","get","JSON","parse","data","write","put","stringify","source","identifier","options","traceFn","hash","contents","update","digest","handleCache","params","span","cacheIdentifier","file","res","setAttribute","err","result"],"mappings":"iEAAA,8BACA,qDACA,8DACA,2E,mFAEA,cAAeA,CAAAA,IAAf,CAAoBC,cAApB,CAAoCC,IAApC,CAA0C,CACxC,KAAMC,CAAAA,YAAY,CAAG,KAAM,iBAAM,iBAAN,EAAyBC,YAAzB,CAAsC,IAC/DC,iBAAQC,GAAR,CAAYL,cAAZ,CAA4BC,IAA5B,CADyB,CAA3B,CAGA,MAAOK,CAAAA,IAAI,CAACC,KAAL,CAAWL,YAAY,CAACM,IAAxB,CAAP,CACD,CAED,QAASC,CAAAA,KAAT,CAAeT,cAAf,CAA+BC,IAA/B,CAAqCO,IAArC,CAA2C,CACzC,MAAO,iBAAM,kBAAN,EAA0BL,YAA1B,CAAuC,IAC5CC,iBAAQM,GAAR,CAAYV,cAAZ,CAA4BC,IAA5B,CAAkCK,IAAI,CAACK,SAAL,CAAeH,IAAf,CAAlC,CADK,CAAP,CAGD,CAED,KAAMP,CAAAA,IAAI,CAAG,SAAUW,MAAV,CAAkBC,UAAlB,CAA8BC,OAA9B,CAAuC,CAClD,MAAO,iBAAM,MAAN,EAAcC,OAAd,CAAsB,IAAM,CACjC,KAAMC,CAAAA,IAAI,CAAG,uBAAW,KAAX,CAAb,CAEA,KAAMC,CAAAA,QAAQ,CAAGX,IAAI,CAACK,SAAL,CAAe,CAAEC,MAAF,CAAUE,OAAV,CAAmBD,UAAnB,CAAf,CAAjB,CAEAG,IAAI,CAACE,MAAL,CAAYD,QAAZ,EAEA,MAAOD,CAAAA,IAAI,CAACG,MAAL,CAAY,KAAZ,CAAP,CACD,CARM,CAAP,CASD,CAVD,CAYe,cAAeC,CAAAA,WAAf,CAA2BC,MAA3B,CAAmC,CAChD,KAAMC,CAAAA,IAAI,CAAG,iBAAM,cAAN,CAAb,CAEA,MAAOA,CAAAA,IAAI,CAACnB,YAAL,CAAkB,SAAY,CACnC,KAAM,CAAES,MAAF,CAAUE,OAAO,CAAG,EAApB,CAAwBS,eAAxB,CAAyCvB,cAAzC,EAA4DqB,MAAlE,CAEA,KAAMG,CAAAA,IAAI,CAAGvB,IAAI,CAACW,MAAD,CAASW,eAAT,CAAjB,CAEA,GAAI,CACF;AACA;AACA,KAAME,CAAAA,GAAG,CAAG,KAAM1B,CAAAA,IAAI,CAACC,cAAD,CAAiBwB,IAAjB,CAAtB,CACAF,IAAI,CAACI,YAAL,CAAkB,OAAlB,CAA2BD,GAAG,CAAG,KAAH,CAAW,MAAzC,EACA,MAAOA,CAAAA,GAAP,CACD,CAAC,MAAOE,GAAP,CAAY,CAAE,CAEhB;AACA;AACA,KAAMC,CAAAA,MAAM,CAAG,KAAM,iBAAM,WAAN,EAAmBzB,YAAnB,CAAgC,SAAY,CAC/D,MAAO,uBAAUS,MAAV,CAAkBE,OAAlB,CAAP,CACD,CAFoB,CAArB,CAIA,KAAML,CAAAA,KAAK,CAACT,cAAD,CAAiBwB,IAAjB,CAAuBI,MAAvB,CAAX,CAEA,MAAOA,CAAAA,MAAP,CACD,CAtBM,CAAP,CAuBD","sourcesContent":["import { createHash } from 'crypto'\nimport { trace } from '../../../../../telemetry/trace'\nimport transform from './transform'\nimport cacache from 'next/dist/compiled/cacache'\n\nasync function read(cacheDirectory, etag) {\n  const cachedResult = await trace('read-cache-file').traceAsyncFn(() =>\n    cacache.get(cacheDirectory, etag)\n  )\n  return JSON.parse(cachedResult.data)\n}\n\nfunction write(cacheDirectory, etag, data) {\n  return trace('write-cache-file').traceAsyncFn(() =>\n    cacache.put(cacheDirectory, etag, JSON.stringify(data))\n  )\n}\n\nconst etag = function (source, identifier, options) {\n  return trace('etag').traceFn(() => {\n    const hash = createHash('md4')\n\n    const contents = JSON.stringify({ source, options, identifier })\n\n    hash.update(contents)\n\n    return hash.digest('hex')\n  })\n}\n\nexport default async function handleCache(params) {\n  const span = trace('handle-cache')\n\n  return span.traceAsyncFn(async () => {\n    const { source, options = {}, cacheIdentifier, cacheDirectory } = params\n\n    const file = etag(source, cacheIdentifier)\n\n    try {\n      // No errors mean that the file was previously cached\n      // we just need to return it\n      const res = await read(cacheDirectory, file)\n      span.setAttribute('cache', res ? 'HIT' : 'MISS')\n      return res\n    } catch (err) {}\n\n    // Otherwise just transform the file\n    // return it to the user asap and write it in cache\n    const result = await trace('transform').traceAsyncFn(async () => {\n      return transform(source, options)\n    })\n\n    await write(cacheDirectory, file, result)\n\n    return result\n  })\n}\n"]}