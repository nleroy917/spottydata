{"version":3,"sources":["../../../../../next-server/server/lib/squoosh/impl.ts"],"names":["decodeBuffer","_buffer","buffer","Buffer","from","firstChunk","slice","firstChunkString","Array","map","v","String","fromCodePoint","join","key","Object","entries","supportedFormats","find","detectors","some","detector","exec","Error","d","dec","decode","Uint8Array","rotate","image","numRotations","ImageData","m","preprocessors","instantiate","data","width","height","resize","p","defaultOptions","encodeJpeg","quality","e","enc","r","encode","defaultEncoderOptions","encodeWebp","encodePng"],"mappings":"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","sourcesContent":["import { codecs as supportedFormats, preprocessors } from './codecs'\nimport ImageData from './image_data'\n\nexport async function decodeBuffer(\n  _buffer: Buffer | Uint8Array\n): Promise<ImageData> {\n  const buffer = Buffer.from(_buffer)\n  const firstChunk = buffer.slice(0, 16)\n  const firstChunkString = Array.from(firstChunk)\n    .map((v) => String.fromCodePoint(v))\n    .join('')\n  const key = Object.entries(supportedFormats).find(([, { detectors }]) =>\n    detectors.some((detector) => detector.exec(firstChunkString))\n  )?.[0] as keyof typeof supportedFormats\n  if (!key) {\n    throw Error(`Buffer has an unsupported format`)\n  }\n  const d = await supportedFormats[key].dec()\n  return d.decode(new Uint8Array(buffer))\n}\n\nexport async function rotate(\n  image: ImageData,\n  numRotations: number\n): Promise<ImageData> {\n  image = ImageData.from(image)\n\n  const m = await preprocessors['rotate'].instantiate()\n  return await m(image.data, image.width, image.height, { numRotations })\n}\n\ntype ResizeOpts = { image: ImageData } & (\n  | { width: number; height?: never }\n  | { height: number; width?: never }\n)\n\nexport async function resize({ image, width, height }: ResizeOpts) {\n  image = ImageData.from(image)\n\n  const p = preprocessors['resize']\n  const m = await p.instantiate()\n  return await m(image.data, image.width, image.height, {\n    ...p.defaultOptions,\n    width,\n    height,\n  })\n}\n\nexport async function encodeJpeg(\n  image: ImageData,\n  { quality }: { quality: number }\n): Promise<Buffer | Uint8Array> {\n  image = ImageData.from(image)\n\n  const e = supportedFormats['mozjpeg']\n  const m = await e.enc()\n  const r = await m.encode!(image.data, image.width, image.height, {\n    ...e.defaultEncoderOptions,\n    quality,\n  })\n  return Buffer.from(r)\n}\n\nexport async function encodeWebp(\n  image: ImageData,\n  { quality }: { quality: number }\n): Promise<Buffer | Uint8Array> {\n  image = ImageData.from(image)\n\n  const e = supportedFormats['webp']\n  const m = await e.enc()\n  const r = await m.encode!(image.data, image.width, image.height, {\n    ...e.defaultEncoderOptions,\n    quality,\n  })\n  return Buffer.from(r)\n}\n\nexport async function encodePng(\n  image: ImageData\n): Promise<Buffer | Uint8Array> {\n  image = ImageData.from(image)\n\n  const e = supportedFormats['oxipng']\n  const m = await e.enc()\n  const r = await m.encode(image.data, image.width, image.height, {\n    ...e.defaultEncoderOptions,\n  })\n  return Buffer.from(r)\n}\n"]}