{"version":3,"sources":["../../../../../next-server/server/lib/squoosh/main.ts"],"names":["getWorker","Worker","path","resolve","__dirname","enableWorkerThreads","numWorkers","Math","max","min","length","computeWorkerKey","method","processBuffer","buffer","operations","encoding","quality","worker","imageData","decodeBuffer","operation","type","rotate","numRotations","width","resize","image","height","Buffer","from","encodeJpeg","encodeWebp","encodePng","Error"],"mappings":"yEAAA,uCACA,kDACA,yCACA,sB,qzBAYA,KAAMA,CAAAA,SAAS,CAAG,oBAChB,IACE,GAAIC,mBAAJ,CAAWC,IAAI,CAACC,OAAL,CAAaC,SAAb,CAAwB,MAAxB,CAAX,CAA4C,CAC1CC,mBAAmB,CAAE,IADqB,CAE1C;AACA;AACAC,UAAU,CAAEC,IAAI,CAACC,GAAL,CAAS,CAAT,CAAYD,IAAI,CAACE,GAAL,CAAS,eAAOC,MAAP,CAAgB,CAAzB,CAA4B,CAA5B,CAAZ,CAJ8B,CAK1CC,gBAAgB,CAAGC,MAAD,EAAYA,MALY,CAA5C,CAFc,CAAlB,CAWO,cAAeC,CAAAA,aAAf,CACLC,MADK,CAELC,UAFK,CAGLC,QAHK,CAILC,OAJK,CAKY,CACjB,KAAMC,CAAAA,MAA+B,CAAGlB,SAAS,EAAjD,CAEA,GAAImB,CAAAA,SAAS,CAAG,KAAMD,CAAAA,MAAM,CAACE,YAAP,CAAoBN,MAApB,CAAtB,CACA,IAAK,KAAMO,CAAAA,SAAX,GAAwBN,CAAAA,UAAxB,CAAoC,CAClC,GAAIM,SAAS,CAACC,IAAV,GAAmB,QAAvB,CAAiC,CAC/BH,SAAS,CAAG,KAAMD,CAAAA,MAAM,CAACK,MAAP,CAAcJ,SAAd,CAAyBE,SAAS,CAACG,YAAnC,CAAlB,CACD,CAFD,IAEO,IAAIH,SAAS,CAACC,IAAV,GAAmB,QAAvB,CAAiC,CACtC,GACED,SAAS,CAACI,KAAV,EACAN,SAAS,CAACM,KADV,EAEAN,SAAS,CAACM,KAAV,CAAkBJ,SAAS,CAACI,KAH9B,CAIE,CACAN,SAAS,CAAG,KAAMD,CAAAA,MAAM,CAACQ,MAAP,CAAc,CAC9BC,KAAK,CAAER,SADuB,CAE9BM,KAAK,CAAEJ,SAAS,CAACI,KAFa,CAAd,CAAlB,CAID,CATD,IASO,IACLJ,SAAS,CAACO,MAAV,EACAT,SAAS,CAACS,MADV,EAEAT,SAAS,CAACS,MAAV,CAAmBP,SAAS,CAACO,MAHxB,CAIL,CACAT,SAAS,CAAG,KAAMD,CAAAA,MAAM,CAACQ,MAAP,CAAc,CAC9BC,KAAK,CAAER,SADuB,CAE9BS,MAAM,CAAEP,SAAS,CAACO,MAFY,CAAd,CAAlB,CAID,CACF,CACF,CAED,OAAQZ,QAAR,EACE,IAAK,MAAL,CACE,MAAOa,CAAAA,MAAM,CAACC,IAAP,CAAY,KAAMZ,CAAAA,MAAM,CAACa,UAAP,CAAkBZ,SAAlB,CAA6B,CAAEF,OAAF,CAA7B,CAAlB,CAAP,CACF,IAAK,MAAL,CACE,MAAOY,CAAAA,MAAM,CAACC,IAAP,CAAY,KAAMZ,CAAAA,MAAM,CAACc,UAAP,CAAkBb,SAAlB,CAA6B,CAAEF,OAAF,CAA7B,CAAlB,CAAP,CACF,IAAK,KAAL,CACE,MAAOY,CAAAA,MAAM,CAACC,IAAP,CAAY,KAAMZ,CAAAA,MAAM,CAACe,SAAP,CAAiBd,SAAjB,CAAlB,CAAP,CACF,QACE,KAAMe,CAAAA,KAAK,CAAE,6BAAF,CAAX,CARJ,CAUD","sourcesContent":["import { Worker } from 'jest-worker'\nimport * as path from 'path'\nimport { execOnce } from '../../../lib/utils'\nimport { cpus } from 'os'\n\ntype RotateOperation = {\n  type: 'rotate'\n  numRotations: number\n}\ntype ResizeOperation = {\n  type: 'resize'\n} & ({ width: number; height?: never } | { height: number; width?: never })\nexport type Operation = RotateOperation | ResizeOperation\nexport type Encoding = 'jpeg' | 'png' | 'webp'\n\nconst getWorker = execOnce(\n  () =>\n    new Worker(path.resolve(__dirname, 'impl'), {\n      enableWorkerThreads: true,\n      // There will be at most 6 workers needed since each worker will take\n      // at least 1 operation type.\n      numWorkers: Math.max(1, Math.min(cpus().length - 1, 6)),\n      computeWorkerKey: (method) => method,\n    })\n)\n\nexport async function processBuffer(\n  buffer: Buffer,\n  operations: Operation[],\n  encoding: Encoding,\n  quality: number\n): Promise<Buffer> {\n  const worker: typeof import('./impl') = getWorker() as any\n\n  let imageData = await worker.decodeBuffer(buffer)\n  for (const operation of operations) {\n    if (operation.type === 'rotate') {\n      imageData = await worker.rotate(imageData, operation.numRotations)\n    } else if (operation.type === 'resize') {\n      if (\n        operation.width &&\n        imageData.width &&\n        imageData.width > operation.width\n      ) {\n        imageData = await worker.resize({\n          image: imageData,\n          width: operation.width,\n        })\n      } else if (\n        operation.height &&\n        imageData.height &&\n        imageData.height > operation.height\n      ) {\n        imageData = await worker.resize({\n          image: imageData,\n          height: operation.height,\n        })\n      }\n    }\n  }\n\n  switch (encoding) {\n    case 'jpeg':\n      return Buffer.from(await worker.encodeJpeg(imageData, { quality }))\n    case 'webp':\n      return Buffer.from(await worker.encodeWebp(imageData, { quality }))\n    case 'png':\n      return Buffer.from(await worker.encodePng(imageData))\n    default:\n      throw Error(`Unsupported encoding format`)\n  }\n}\n"]}