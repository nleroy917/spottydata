{"version":3,"sources":["../../../../../next-server/lib/router/utils/prepare-destination.ts"],"names":["getSafeParamName","paramName","newParamName","i","length","charCode","charCodeAt","matchHas","req","has","query","params","initialQueryValues","window","Object","values","__NEXT_INIT_QUERY","Array","from","URLSearchParams","location","search","allMatch","every","hasItem","value","key","type","toLowerCase","headers","cookies","includes","encodeURIComponent","host","hostname","split","matcher","RegExp","matches","match","groups","keys","forEach","groupKey","compileNonPath","replace","pathToRegexp","compile","validate","substr","prepareDestination","destination","appendParamsToQuery","parsedDestination","assign","hadLocale","__nextLocale","__nextDefaultLocale","startsWith","pathname","searchParams","hash","port","protocol","href","URL","destQuery","destPath","destPathParamKeys","destPathParams","map","name","destinationCompiler","newUrl","strOrArray","entries","isArray","paramKeys","filter","some","err","message","Error"],"mappings":"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","sourcesContent":["import { IncomingMessage } from 'http'\nimport { ParsedUrlQuery } from 'querystring'\nimport { searchParamsToUrlQuery } from './querystring'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\nimport { RouteHas } from '../../../../lib/load-custom-routes'\n\ntype Params = { [param: string]: any }\n\n// ensure only a-zA-Z are used for param names for proper interpolating\n// with path-to-regexp\nexport const getSafeParamName = (paramName: string) => {\n  let newParamName = ''\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i)\n\n    if (\n      (charCode > 64 && charCode < 91) || // A-Z\n      (charCode > 96 && charCode < 123) // a-z\n    ) {\n      newParamName += paramName[i]\n    }\n  }\n  return newParamName\n}\n\nexport function matchHas(\n  req: IncomingMessage,\n  has: RouteHas[],\n  query: Params\n): false | Params {\n  const params: Params = {}\n  let initialQueryValues: string[] = []\n\n  if (typeof window === 'undefined') {\n    initialQueryValues = Object.values((req as any).__NEXT_INIT_QUERY)\n  }\n  if (typeof window !== 'undefined') {\n    initialQueryValues = Array.from(\n      new URLSearchParams(location.search).values()\n    )\n  }\n\n  const allMatch = has.every((hasItem) => {\n    let value: undefined | string\n    let key = hasItem.key\n\n    switch (hasItem.type) {\n      case 'header': {\n        key = key!.toLowerCase()\n        value = req.headers[key] as string\n        break\n      }\n      case 'cookie': {\n        value = (req as any).cookies[hasItem.key]\n        break\n      }\n      case 'query': {\n        // preserve initial encoding of query values\n        value = query[key!]\n\n        if (initialQueryValues.includes(value || '')) {\n          value = encodeURIComponent(value!)\n        }\n        break\n      }\n      case 'host': {\n        const { host } = req?.headers || {}\n        // remove port from host if present\n        const hostname = host?.split(':')[0].toLowerCase()\n        value = hostname\n        break\n      }\n      default: {\n        break\n      }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key!)] = value\n      return true\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`)\n      const matches = value.match(matcher)\n\n      if (matches) {\n        if (matches.groups) {\n          Object.keys(matches.groups).forEach((groupKey) => {\n            params[groupKey] = matches.groups![groupKey]\n          })\n        } else if (hasItem.type === 'host' && matches[0]) {\n          params.host = matches[0]\n        }\n        return true\n      }\n    }\n    return false\n  })\n\n  if (allMatch) {\n    return params\n  }\n  return false\n}\n\nexport function compileNonPath(value: string, params: Params): string {\n  if (!value.includes(':')) {\n    return value\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value\n        .replace(\n          new RegExp(`:${key}\\\\*`, 'g'),\n          `:${key}--ESCAPED_PARAM_ASTERISKS`\n        )\n        .replace(\n          new RegExp(`:${key}\\\\?`, 'g'),\n          `:${key}--ESCAPED_PARAM_QUESTION`\n        )\n        .replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)\n        .replace(\n          new RegExp(`:${key}(?!\\\\w)`, 'g'),\n          `--ESCAPED_PARAM_COLON${key}`\n        )\n    }\n  }\n  value = value\n    .replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1')\n    .replace(/--ESCAPED_PARAM_PLUS/g, '+')\n    .replace(/--ESCAPED_PARAM_COLON/g, ':')\n    .replace(/--ESCAPED_PARAM_QUESTION/g, '?')\n    .replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')\n\n  // the value needs to start with a forward-slash to be compiled\n  // correctly\n  return pathToRegexp\n    .compile(`/${value}`, { validate: false })(params)\n    .substr(1)\n}\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean\n) {\n  let parsedDestination: {\n    query?: ParsedUrlQuery\n    protocol?: string\n    hostname?: string\n    port?: string\n  } & ReturnType<typeof parseRelativeUrl> = {} as any\n\n  // clone query so we don't modify the original\n  query = Object.assign({}, query)\n  const hadLocale = query.__nextLocale\n  delete query.__nextLocale\n  delete query.__nextDefaultLocale\n\n  if (destination.startsWith('/')) {\n    parsedDestination = parseRelativeUrl(destination)\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href,\n    } = new URL(destination)\n\n    parsedDestination = {\n      pathname,\n      query: searchParamsToUrlQuery(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href,\n    }\n  }\n\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = compileNonPath(value, params)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  let paramKeys = Object.keys(params)\n\n  // remove internal param for i18n\n  if (hadLocale) {\n    paramKeys = paramKeys.filter((name) => name !== 'nextInternalLocale')\n  }\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  try {\n    newUrl = destinationCompiler(params)\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete (parsedDestination as any).search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]}